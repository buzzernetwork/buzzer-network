BUG PREVENTION & BEST PRACTICES - BUZZER NETWORK
=================================================

This file documents meta patterns and best practices discovered during TDD implementation to prevent bugs and improve code quality.

1. SMART CONTRACT BEST PRACTICES
---------------------------------

1.1 Access Control
- ALWAYS use modifiers for access control (don't inline require statements)
- Use OpenZeppelin's Ownable or AccessControl for standard patterns
- Test access control exhaustively (try unauthorized access in tests)
- Document who can call each function

1.2 Reentrancy Protection
- Use ReentrancyGuard modifier for functions that modify state and call external contracts
- Follow checks-effects-interactions pattern
- Test reentrancy attacks explicitly

1.3 Integer Overflow/Underflow
- Use Solidity 0.8+ (automatic overflow checks)
- Or use SafeMath library for older versions
- Test boundary conditions (max uint256, zero, negative if using int)

1.4 Gas Optimization
- Batch operations when possible (reduce transaction count)
- Use events instead of storage for non-critical data
- Cache storage variables in memory for multiple reads
- Use uint256 for consistency (gas-efficient)
- Avoid loops with unbounded size

1.5 Error Handling
- Use custom error types (Solidity 0.8.4+) for gas efficiency
- Provide clear error messages
- Test all error conditions

1.6 Testing Strategy
- Test all functions (including edge cases)
- Test access control (unauthorized access should fail)
- Test reentrancy scenarios
- Test gas usage (identify optimization opportunities)
- Use fuzzing tools (Echidna, Foundry fuzz)

2. BACKEND API BEST PRACTICES
------------------------------

2.1 Authentication & Authorization
- Always verify wallet signatures server-side (never trust client)
- Use JWT tokens with appropriate expiration
- Validate wallet addresses (checksum, format)
- Implement rate limiting per wallet address
- Log all authentication attempts

2.2 Input Validation
- Validate ALL inputs (never trust client data)
- Use schema validation (Zod, Joi, Yup)
- Validate data types, ranges, formats
- Sanitize inputs (prevent injection attacks)
- Validate file uploads (size, type, content)

2.3 Database Operations
- Use parameterized queries (prevent SQL injection)
- Use transactions for multi-step operations
- Handle database errors gracefully
- Use connection pooling
- Add indexes for all foreign keys and frequently queried columns
- Use migrations (never modify schema directly)

2.4 Error Handling
- Never expose internal errors to clients
- Use standardized error responses
- Log errors with context (request ID, user ID, stack trace)
- Implement retry logic for transient failures
- Use circuit breakers for external services

2.5 Idempotency
- Use idempotency keys for all financial operations
- Store idempotency keys in Redis (with TTL)
- Check idempotency before processing
- Return same result for duplicate requests

2.6 Race Conditions
- Use database transactions with proper isolation levels
- Use locks for critical sections (Redis distributed locks)
- Test concurrent operations
- Use optimistic locking for updates

2.7 Testing
- Write unit tests for all business logic
- Write integration tests for API endpoints
- Test error cases (invalid inputs, edge cases)
- Test concurrent operations
- Use test database (never use production data)

3. AD SERVING BEST PRACTICES
------------------------------

3.1 Performance
- Cache campaign data aggressively (Redis, 5min TTL)
- Cache matching results (Redis, 1min TTL)
- Use CDN for ad creatives
- Optimize ad request endpoint (target: <100ms)
- Monitor cache hit rates (target: >80%)

3.2 Matching Algorithm
- Test all targeting combinations
- Handle edge cases (no matches, tied bids)
- Implement fair distribution for tied bids
- Validate matching results (correct campaign selected)
- Monitor matching performance

3.3 X402 Compliance
- Strictly follow X402 protocol specification
- Test with X402 standard test suite
- Validate all ad request parameters
- Return correct response format
- Handle errors according to X402 spec

3.4 Tracking
- Use idempotency keys for all tracking events
- Implement duplicate detection (prevent double-counting)
- Validate tracking events (fraud detection)
- Batch write tracking events (reduce database load)
- Use time-series database (TimescaleDB) for analytics

4. PAYMENT & SETTLEMENT BEST PRACTICES
---------------------------------------

4.1 Earnings Calculation
- Calculate earnings from verified events only
- Use precise decimal arithmetic (avoid floating point)
- Apply revenue share consistently (85/15)
- Store earnings in database (don't recalculate on demand)
- Validate earnings calculations (unit tests)

4.2 Settlement
- Chunk large batches (prevent gas limit issues)
- Estimate gas before transactions
- Implement retry logic for failed transactions
- Monitor settlement success rates
- Log all settlement transactions
- Handle partial failures gracefully

4.3 Smart Contract Integration
- Always estimate gas before transactions
- Handle transaction failures gracefully
- Implement retry logic with exponential backoff
- Monitor transaction confirmations
- Store transaction hashes for audit trail

4.4 Security
- Never store private keys (use wallet abstraction)
- Validate all amounts before transactions
- Check balances before operations
- Implement minimum payout thresholds
- Use multi-sig for large amounts (optional)

5. FRONTEND BEST PRACTICES
---------------------------

5.1 Wallet Integration
- Handle wallet connection errors gracefully
- Support multiple wallet providers (MetaMask, WalletConnect)
- Provide clear error messages
- Test on multiple devices and browsers
- Handle network switching (BASE network)

5.2 State Management
- Use appropriate state management (Zustand, Redux)
- Don't store sensitive data in state
- Clear state on logout
- Handle loading and error states
- Optimize re-renders (use React.memo, useMemo)

5.3 Form Validation
- Validate on both client and server
- Provide real-time feedback
- Show clear error messages
- Prevent double submissions
- Handle network errors gracefully

5.4 Performance
- Lazy load components
- Optimize images (next/image)
- Use CDN for static assets
- Minimize bundle size
- Monitor Core Web Vitals

6. DATABASE BEST PRACTICES
--------------------------

6.1 Schema Design
- Use appropriate data types
- Add indexes for all foreign keys
- Add indexes for frequently queried columns
- Use time-series database for analytics (TimescaleDB)
- Normalize data appropriately

6.2 Queries
- Use parameterized queries (prevent injection)
- Avoid N+1 queries (use joins or eager loading)
- Profile slow queries (use EXPLAIN ANALYZE)
- Use database connection pooling
- Set appropriate query timeouts

6.3 Migrations
- Always use migrations (never modify schema directly)
- Test migrations on staging first
- Make migrations reversible when possible
- Backup database before migrations
- Document migration purpose

6.4 Data Integrity
- Use foreign key constraints
- Use database transactions for multi-step operations
- Validate data before saving
- Implement soft deletes when appropriate
- Archive old data (don't delete)

7. SECURITY BEST PRACTICES
--------------------------

7.1 Authentication
- Never trust client-side authentication
- Verify wallet signatures server-side
- Use strong JWT secrets
- Implement token expiration
- Log all authentication attempts

7.2 Authorization
- Check permissions for every operation
- Use role-based access control
- Validate ownership (publisher owns site, advertiser owns campaign)
- Test authorization exhaustively

7.3 Data Protection
- Encrypt sensitive data at rest
- Use TLS for all connections
- Don't log sensitive data
- Implement data deletion (GDPR compliance)
- Use environment variables for secrets

7.4 Fraud Prevention
- Implement multiple fraud detection layers
- Monitor for suspicious patterns
- Rate limit all endpoints
- Validate all tracking events
- Use ML models for advanced detection

8. TESTING BEST PRACTICES
--------------------------

8.1 Test Coverage
- Aim for 80%+ code coverage
- Test all business logic
- Test error cases
- Test edge cases
- Test integration points

8.2 Test Organization
- Group tests by feature/component
- Use descriptive test names
- Follow Arrange-Act-Assert pattern
- Keep tests independent
- Clean up after tests

8.3 Test Data
- Use factories/fixtures for test data
- Don't use production data
- Reset database between tests
- Use realistic test data
- Test with various data scenarios

8.4 Continuous Testing
- Run tests on every commit (CI)
- Run tests before deployment
- Monitor test coverage trends
- Fix failing tests immediately
- Review test failures regularly

9. DEPLOYMENT BEST PRACTICES
-----------------------------

9.1 Environment Management
- Use environment variables for configuration
- Never commit secrets to repository
- Use different configs for dev/staging/prod
- Validate environment variables on startup
- Document all environment variables

9.2 Deployment Process
- Use CI/CD pipeline
- Run tests before deployment
- Deploy to staging first
- Monitor deployment
- Have rollback plan ready

9.3 Monitoring
- Monitor application metrics (APM)
- Monitor error rates
- Monitor performance metrics
- Set up alerts for critical issues
- Log all important events

9.4 Backup & Recovery
- Backup database regularly
- Test backup restoration
- Document recovery procedures
- Store backups in multiple locations
- Version control all configuration

10. CODE QUALITY BEST PRACTICES
--------------------------------

10.1 Code Organization
- Follow consistent file structure
- Use meaningful variable/function names
- Keep functions small and focused
- Avoid deep nesting
- Use appropriate design patterns

10.2 Documentation
- Document complex logic
- Document API endpoints
- Document smart contract functions
- Keep README updated
- Document deployment procedures

10.3 Code Review
- Review all code before merging
- Check for security issues
- Check for performance issues
- Verify tests are adequate
- Ensure consistency

10.4 Refactoring
- Refactor regularly
- Don't accumulate technical debt
- Improve code incrementally
- Test after refactoring
- Document refactoring decisions

11. SPECIFIC PATTERNS FOR BUZZER NETWORK
-----------------------------------------

11.1 Ad Serving Pattern
- Cache campaign data in Redis (5min TTL)
- Cache matching results (1min TTL)
- Use CDN for ad creatives
- Batch write tracking events
- Monitor cache hit rates

11.2 Payment Pattern
- Calculate earnings from verified events only
- Store earnings in database
- Chunk settlement batches
- Estimate gas before transactions
- Retry failed transactions

11.3 Quality Scoring Pattern
- Cache quality scores (don't recalculate frequently)
- Re-score periodically (daily cron)
- Update scores based on performance
- Store scores in database
- Use scores for matching

11.4 Fraud Detection Pattern
- Multiple detection layers (bot, duplicate, pattern)
- Store fraud scores
- Flag suspicious events for review
- Monitor fraud rates
- Update detection models regularly

12. LESSONS LEARNED
-------------------

[To be filled in during implementation with actual lessons learned]

Example:
- Always validate wallet signatures server-side (learned from BUG-001)
- Use idempotency keys for all financial operations (learned from BUG-003)
- Chunk large batches to prevent gas limit issues (learned from BUG-004)
- Add indexes for all foreign keys (learned from BUG-005)

---

CONTINUOUS IMPROVEMENT:
-----------------------
- Review this file regularly
- Update with new patterns discovered
- Share learnings with team
- Use patterns to prevent similar bugs
- Refine patterns based on experience

